
from .User import User
from .Agent import Assistant
from .UtilityAgents import Splitter, Joiner, Decider
from .Node import Node
import asyncio
import re
from typing import Any, AsyncGenerator, Coroutine, List, Literal
import logging 

logger = logging.getLogger(__name__)

class Chat(Node):
    """
    A class representing a chat environment, extending the Node class. 
    This class facilitates chat interactions in a network of actors.

    Attributes:
        deciders (dict): A dictionary mapping thread names to decider agents.
    """

    def __init__(self, actors:list[Node], **kwargs) -> None:
        """
        Initializes a Chat instance with inherited properties from Node.
        It also initializes an empty dictionary for deciders.
        """
        super().__init__(**kwargs)
        self.actors = actors
        self.deciders = {}

    async def get_completion(self, message: str, threadname='main') -> AsyncGenerator[str, None]:
        """
        An asynchronous generator that handles the flow of messages within the chat node.

        Args:
            message (str): The initial message to start the chat.
            threadname (str): The name of the thread for managing separate chat flows.

        Yields:
            str: Messages generated during the chat interaction.

        This method sets up a decider for the chat and then asynchronously iterates through
        the messages generated by the decider's send_message_gen method.
        """
        logger.info(f"Starting node completion for chat in thread '{threadname}'")
        
        # Create the decider with the goal in mind
        
        goal = message
        self.deciders[threadname]:Decider = Decider(self, threadname=threadname, goal=goal)

        # Continue to call functions until the function calling stops. Current working on fixing the situation where the decider needs user input. 
        # I may implement a USER INPUT function, for the decider to continue to call other agents
        
        
        while self.deciders[threadname].goal_achieved == False:
            async for mes in self.deciders[threadname].get_completion(goal, threadname):
                yield mes
                message = mes

        return

    async def start_chat(self, message = "", userchat=True) -> str:
        """
        Starts the chat interaction in the terminal. Usually used as a demo. 

        Args:
            message (str): The initial message to start the chat.
            userchat (bool): Flag indicating whether the chat is user-initiated.

        Returns:
            str: The final message after the chat interaction.

        This method manages the chat interaction based on whether it's initiated by a user
        or an assistant. It sets up the appropriate actor to start the chat and processes
        messages asynchronously.
        """
        
        self.deciders['main'] = Decider(self)
        # self.build_decider()
        
        if userchat:
            userid = 0
            # for i, actor in enumerate(self.actors):
            #     if isinstance(actor, User):
            #         userid = i
            usermessage = ""
            while usermessage != "stop":
                usermessage = input("user: ")
                async for m in self.deciders['main'].get_completion(usermessage):
                    message = m
                    print(m)
                    print('_'*15)

            
        else:
            assistantid = 0
            for i, actor in enumerate(self.actors):
                if isinstance(actor, Assistant):
                    assistantid = i
            # print(self.actors[assistantid])
            async for m in self.actors[assistantid].get_completion(message):
                    print(m)
                    print('_'*15)
                    message = m
            async for m in await self.deciders['main'].get_completion(message):
                    print(m)
                    print('_'*15)

                    message = m

        return message
    
    def startup(self):
        asyncio.run(self.start_chat())

    def demo_gradio(self, height=600): 
        """
    Launches an interactive chat interface using Gradio.

    This method sets up a Gradio interface for the chat environment, allowing users to
    interact with the chatbot in real-time. It leverages Gradio's `Blocks` and `Chatbot`
    to create a user-friendly chat interface.

    Args:
        height (int): The height of the chatbot interface in pixels. Defaults to 600.

    Raises:
        ImportError: If Gradio is not installed.

    The method initializes a chatbot and text box for user input. It defines two
    asynchronous functions, `user` and `bot`, to handle the user's input and the bot's
    responses, respectively. The user function processes the user's message and updates
    the chat history. The bot function implements the chatbot logic, yielding messages
    from the generator. The chat history is updated with both user and bot messages.
    This function also handles the end of the conversation if necessary.

    After defining the user and bot functions, the method sets up event chaining in
    Gradio, linking the text box input to these functions and updating the chatbot
    interface accordingly. The Gradio demo is then launched, providing an interactive
    chat experience.
    """
        
        self.build_decider()
        try:
            import gradio as gr
        except ImportError:
            raise Exception("Please install gradio: pip install gradio")

        with gr.Blocks() as demo:
            chatbot = gr.Chatbot(height=600)
            msg = gr.Textbox()

            async def user(user_message, history):
                # Append the user message with a placeholder for bot response
                
                user_message = "ðŸ‘¤ User: " + user_message.strip()
                return "", history + [[user_message, None]]

            async def bot(history):
                # Replace this with your actual chatbot logic
                user_message = history[-1][0]

                try:
                    # Yield each message from the generator
                    async for message in self.deciders['main'].get_completion(user_message, 'main'):
                        message = re.sub(r'\\\\', r'\\', message)
                        history.append([None, message])
                        print(history)
                        yield history
                    
                    history.append([None, "Quotas Completed"])
                    
                    yield history
                        
                except StopIteration:
                    # Handle the end of the conversation if necessary
                    pass

            # Chain the events
            msg.submit(user, [msg, chatbot], [msg, chatbot], queue=False).then(
                bot, chatbot, chatbot
            )

            # Enable queuing for streaming intermediate outputs
            demo.queue()

        # Launch the demo
        demo.launch()
        
    def __repr__(self) -> str:
        """
        Returns a string representation of the Node.

        Returns:
            str: A string representation, showing the name of the node.
        """
        return f"{self.name} Chat"
        

     
class UtilityNode(Node):
    
    def __init__(self, placetype:type, id) -> None:
        self.placetype:type = placetype
        self.id = id
        
    def get_completion(self, message: str) -> Coroutine[Any, Any, AsyncGenerator[str, None]]:
        return ""

    def __repr__(self) -> str:
        """
        Returns a string representation of the Node.

        Returns:
            str: A string representation, showing the name of the node.
        """
        return f"{self.placetype} Utility Node"

        
        
    def build_splitter(self, out:list[Node]) -> Node:
        """
        Creates a splitter agent to delegate tasks among multiple nodes.

        Args:
            out (list[Node]): A list of output nodes to which tasks will be delegated.

        Returns:
            ChatOne: A ChatOne instance representing a chat with the splitter agent.

        This method creates a Splitter agent that takes an input message and delegates tasks
        among the provided output nodes. If there is only one output node, tasks are split
        equally among the same group of agents. For multiple output nodes, tasks are split
        according to their descriptions.
        """
        descriptions = {i:{"name":o.name, "description": o.description, "node":o} for i, o in enumerate(out)}
        
        splitter = Splitter(name=f"Splitter for {out}", descriptions=descriptions, out_nodes=out, comm=self.comm)
    
        
        # Return the splittting Node
        return splitter

    def build_joiner(self) -> Node:
        joiner = Joiner(name=f"Joiner", comm=self.comm)
    
        # Return the splittting Node
        return joiner
        
    
        
def SplitJoinPair(id=0):
    return UtilityNode(placetype=Splitter, id=id, ), UtilityNode(placetype=Joiner, id=id)

    