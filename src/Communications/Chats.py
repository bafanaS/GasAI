
from Actors import User, Assistant
from .Node import Node
from Actors import Decider
import asyncio
import re
from typing import AsyncGenerator
import logging 

logger = logging.getLogger(__name__)

class Chat(Node):
    """
    A class representing a chat environment, extending the Node class. 
    This class facilitates chat interactions in a network of actors.

    Attributes:
        deciders (dict): A dictionary mapping thread names to decider agents.
    """

    def __init__(self, **kwargs) -> None:
        """
        Initializes a Chat instance with inherited properties from Node.
        It also initializes an empty dictionary for deciders.
        """
        super().__init__(**kwargs)
        self.deciders = {}

    async def get_node_completion_gen(self, message: str, threadname='main') -> AsyncGenerator[str, None]:
        """
        An asynchronous generator that handles the flow of messages within the chat node.

        Args:
            message (str): The initial message to start the chat.
            threadname (str): The name of the thread for managing separate chat flows.

        Yields:
            str: Messages generated during the chat interaction.

        This method sets up a decider for the chat and then asynchronously iterates through
        the messages generated by the decider's send_message_gen method.
        """
        logger.info(f"Starting node completion for chat in thread '{threadname}'")
        
        # Create the decider with the goal in mind
        
        goal = message
        self.deciders[threadname]:Decider = Decider(self, threadname=threadname, goal=goal)

        # Continue to call functions until the function calling stops. Current working on fixing the situation where the decider needs user input. 
        # I may implement a USER INPUT function, for the decider to continue to call other agents
        
        
        while self.deciders[threadname].goal_achieved == False:
            async for mes in self.deciders[threadname].send_message_gen(goal, threadname):
                yield mes
                message = mes

        return

    async def start_chat(self, message = "", userchat=True) -> str:
        """
        Starts the chat interaction in the terminal. Usually used as a demo. 

        Args:
            message (str): The initial message to start the chat.
            userchat (bool): Flag indicating whether the chat is user-initiated.

        Returns:
            str: The final message after the chat interaction.

        This method manages the chat interaction based on whether it's initiated by a user
        or an assistant. It sets up the appropriate actor to start the chat and processes
        messages asynchronously.
        """
        
        self.deciders['main'] = Decider(self)
        # self.build_decider()
        
        if userchat:
            userid = 0
            # for i, actor in enumerate(self.actors):
            #     if isinstance(actor, User):
            #         userid = i
            usermessage = ""
            while usermessage != "stop":
                usermessage = input("user: ")
                async for m in self.deciders['main'].send_message_gen(usermessage):
                    message = m
                    print(m)
                    print('_'*15)

            
        else:
            assistantid = 0
            for i, actor in enumerate(self.actors):
                if isinstance(actor, Assistant):
                    assistantid = i
            # print(self.actors[assistantid])
            async for m in self.actors[assistantid].send_message_gen(message):
                    print(m)
                    print('_'*15)
                    message = m
            async for m in await self.deciders['main'].send_message_gen(message):
                    print(m)
                    print('_'*15)

                    message = m

        return message
    
    def startup(self):
        asyncio.run(self.start_chat())

    def demo_gradio(self, height=600): 
        """
    Launches an interactive chat interface using Gradio.

    This method sets up a Gradio interface for the chat environment, allowing users to
    interact with the chatbot in real-time. It leverages Gradio's `Blocks` and `Chatbot`
    to create a user-friendly chat interface.

    Args:
        height (int): The height of the chatbot interface in pixels. Defaults to 600.

    Raises:
        ImportError: If Gradio is not installed.

    The method initializes a chatbot and text box for user input. It defines two
    asynchronous functions, `user` and `bot`, to handle the user's input and the bot's
    responses, respectively. The user function processes the user's message and updates
    the chat history. The bot function implements the chatbot logic, yielding messages
    from the generator. The chat history is updated with both user and bot messages.
    This function also handles the end of the conversation if necessary.

    After defining the user and bot functions, the method sets up event chaining in
    Gradio, linking the text box input to these functions and updating the chatbot
    interface accordingly. The Gradio demo is then launched, providing an interactive
    chat experience.
    """
        
        self.build_decider()
        try:
            import gradio as gr
        except ImportError:
            raise Exception("Please install gradio: pip install gradio")

        with gr.Blocks() as demo:
            chatbot = gr.Chatbot(height=600)
            msg = gr.Textbox()

            async def user(user_message, history):
                # Append the user message with a placeholder for bot response
                
                user_message = "ğŸ‘¤ User: " + user_message.strip()
                return "", history + [[user_message, None]]

            async def bot(history):
                # Replace this with your actual chatbot logic
                user_message = history[-1][0]

                try:
                    # Yield each message from the generator
                    async for message in self.deciders['main'].send_message_gen(user_message, 'main'):
                        message = re.sub(r'\\\\', r'\\', message)
                        history.append([None, message])
                        print(history)
                        yield history
                    
                    history.append([None, "Quotas Completed"])
                    
                    yield history
                        
                except StopIteration:
                    # Handle the end of the conversation if necessary
                    pass

            # Chain the events
            msg.submit(user, [msg, chatbot], [msg, chatbot], queue=False).then(
                bot, chatbot, chatbot
            )

            # Enable queuing for streaming intermediate outputs
            demo.queue()

        # Launch the demo
        demo.launch()
        

# One shot chat environment. 
class ChatOne(Node):
    """
    A class representing a one-shot chat environment, extending the Node class.

    This class is designed for chat interactions involving a single message exchange
    between a user and an agent. It is suitable for scenarios where a single response
    is expected from an agent.

    Attributes:
        agent (Agent): The agent responsible for handling the chat interaction.
    """

    def __init__(self, actors = [], **kwargs) -> None:
        """
        Initializes a ChatOne instance with inherited properties from Node.
        The first actor in the node is set as the agent responsible for the chat.
        """
        super().__init__(**kwargs)
        self.agent = self.actors[0]
        
    def __init__(self, actor, comm, **kwargs):
        self.agent = actor
        super().__init__(actors=[actor], name=actor.name, purpose=actor.description, comm=comm, **kwargs)

    async def get_node_completion_gen(self, message: str, threadname='main') -> AsyncGenerator[str, None]:
        """
        An asynchronous generator for one-shot chat interactions.

        Processes a single message through the agent and yields the response.

        Args:
            message (str): The initial message to start the chat.
            threadname (str): The name of the thread for the chat operation.

        Yields:
            str: The response message from the agent.
        """
        async for m in self.agent.send_message_gen(message, threadname=threadname):
            yield m
            
    async def start_chat(self) -> str:
        """
        Starts the chat interaction in the terminal. Usually used as a demo. 

        Args:
            message (str): The initial message to start the chat.
            userchat (bool): Flag indicating whether the chat is user-initiated.

        Returns:
            str: The final message after the chat interaction.

        This method manages the chat interaction based on whether it's initiated by a user
        or an assistant. It sets up the appropriate actor to start the chat and processes
        messages asynchronously.
        """
       
        usermessage = ""
        while usermessage != "stop":
            async for m in User().send_message_gen():
                usermessage = m
            async for m in self.get_node_completion_gen(usermessage):
                message = m
                print(m)
                print('_'*15)

                
                if self.outs_to_file:
                    self.save_message_to_file(m)
    
    def startup(self):
        asyncio.run(self.start_chat())